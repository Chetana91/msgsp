package cs583;

import java.util.ArrayList;

public class CandidateGeneration {

	/**
	 * @param L
	 * @return
	 */
	public FrequentSequence frequent1ItemsetGen (ArrayList<Integer> L) {
		FrequentSequence f1 = new FrequentSequence();
		System.out.println("Finding F1");
		for (Integer item : L) {
			if ((MsGsp.ItemCountMap.get(item) * 1.0 / MsGsp.N) >= MsGsp.MISMap.get(item)) {
				System.out.println(item);
				DataSequence dataSequence = new DataSequence(item);
				f1.addIntermediateSequence(dataSequence);
			}
		}
		System.out.println("f1 size: " + f1.sequence.size());
		f1.printFrequentSequence('F', 1);
		return f1;
	}
	
	/**
	 * function takes argument L and returns a superset of the set of all
	 * frequent 2 itemsets
	 **/
	public FrequentSequence level2CandidateGen(ArrayList<Integer> L) {
		FrequentSequence C2 = new FrequentSequence();
		System.out.println("\nIn Level2 candidate generation");

		for (int i = 0; i < L.size(); i++) {
			if (MsGsp.ItemCountMap.get(L.get(i)) * 1.0 / MsGsp.N >= (MsGsp.MISMap.get(L.get(i)) * 1.0)) {
				for (int h = i; h < L.size(); h++) {
					if (MsGsp.ItemCountMap.get(L.get(h)) * 1.0 / MsGsp.N >= (MsGsp.MISMap.get(L.get(i)) * 1.0)) {
						if (Math.abs(MsGsp.ItemCountMap.get(L.get(i)).intValue() - MsGsp.ItemCountMap.get(L.get(h)).intValue()) <= MsGsp.SDC * MsGsp.N) {
							ItemSet itemset = new ItemSet();
							int a = L.get(i);
							int b = L.get(h);

							// adding sequence<{a},{b}>
							ItemSet firstset = new ItemSet();
							firstset.items.add(a);
							ItemSet secondset = new ItemSet();
							secondset.items.add(b);
							DataSequence tempsequence1 = new DataSequence();
							tempsequence1.sequence.add(firstset);
							tempsequence1.sequence.add(secondset);
							C2.addIntermediateSequence(tempsequence1); // tempsequence1 is <{a},{b}>

							if (a <= b) {
								itemset.items.add(a);
								itemset.items.add(b);
							} else {
								itemset.items.add(b);
								itemset.items.add(a);
							}
							
							if (a != b) {
								DataSequence tempsequence2 = new DataSequence();
								tempsequence2.sequence.add(itemset); // adds tempsequence2 <{a,b}>
								C2.addIntermediateSequence(tempsequence2);
							}
							// TODO should we include <{b},{a}>
						}
					}
				}

			}

		}// end of outer For

		// printing to check Level-2 candidate Generation function
		System.out.println("\n Level-2 candidate size : " + C2.sequence.size()
				+ "\n");
		C2.printFrequentSequence('C', 2);
		System.out.println("\n ending of level 2 candidate generation");
		return C2;
	}

	public FrequentSequence MSCandidateGen_SPM(FrequentSequence fk_1) {

		// A. candidates are generated by joining fk_1 with fk_1

		int i = 0; // for selecting index of the sequence from first fk_1

		for (DataSequence s1 : fk_1.sequence) {
			for (DataSequence s2 : fk_1.sequence) {

				int firstItem = s1.getFirstItem(i);
				int lastItem = s1.getLastItem(i);

				// B. Compare if first item has the smallest MIS value
				if (s1.isItemMisSmallest(i, firstItem)) {
					System.out.println("FirstItem is smallest");
					boolean flag = checkJoinCondition(s1, s2);
				}
				// C. Compare if last item has the smallest MIS value
				else if (s1.isItemMisSmallest(i, lastItem)) {
					System.out.println("LastItem is smallest");
				}
				// D. Use join step from MS-Apriori
				else {
					System.out.println("Use join step from MS-Apriori");
				}

				break;
			}
		}

		return null;
	}

	public boolean checkJoinCondition(DataSequence s1, DataSequence s2) {
		return false;
	}

}
